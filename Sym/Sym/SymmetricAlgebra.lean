import Mathlib
import Sym.newHomogeneousRelation
import Aesop

open MvPolynomial RingQuot

noncomputable section
variable (R : Type*) [CommRing R]
variable (L : Type*) [AddCommMonoid L] [Module R L]
local notation "Œπ" => TensorAlgebra.Œπ R

-- def I := TwoSidedIdeal.span {(Œπ‚Çú x * Œπ‚Çú y - Œπ‚Çú y * Œπ‚Çú x) | (x : L) (y : L)}

inductive SymRel : (TensorAlgebra R L) ‚Üí (TensorAlgebra R L) ‚Üí Prop where
  | mul_comm (x y : L) : SymRel (Œπ x * Œπ y) (Œπ y * Œπ x)


instance : IsHomogeneousRelation (fun (n : ‚Ñï) ‚Ü¶ (LinearMap.range (Œπ : L ‚Üí‚Çó[R] TensorAlgebra R L) ^ n)) (SymRel R L) :=‚ü® by
  have h_iota (x y : L) : (Œπ x * Œπ y) ‚àà (fun (n : ‚Ñï) ‚Ü¶ (LinearMap.range (Œπ : L ‚Üí‚Çó[R] TensorAlgebra R L) ^ n)) 2 := by
    simp only [pow_two]; apply Submodule.mul_mem_mul; simp; simp
  intro x y h i
  induction h
  case mul_comm x y =>
    have : (SymRel R L) (Œπ x * Œπ y) (Œπ y * Œπ x) := by apply SymRel.mul_comm x y
    have h_decompose : (Œπ x * Œπ y) = ((DirectSum.decompose (fun n ‚Ü¶ LinearMap.range Œπ ^ n) (Œπ x * Œπ y)) 2) := by
        exact
          Eq.symm (DirectSum.decompose_of_mem_same (fun n ‚Ü¶ LinearMap.range Œπ ^ n) (h_iota x y))
    have h_decompose' : (Œπ y * Œπ x) = ((DirectSum.decompose (fun n ‚Ü¶ LinearMap.range Œπ ^ n) (Œπ y * Œπ x)) 2) := by
        exact
          Eq.symm (DirectSum.decompose_of_mem_same (fun n ‚Ü¶ LinearMap.range Œπ ^ n) (h_iota y x))
    have h_zero : ‚àÄ i ‚â† 2, (GradedRing.proj (fun (n : ‚Ñï) ‚Ü¶ (LinearMap.range (Œπ : L ‚Üí‚Çó[R] TensorAlgebra R L) ^ n)) i (Œπ x * Œπ y)) = 0 := by
      intro i h
      rw [GradedRing.proj_apply, h_decompose]
      simp only [DirectSum.decompose_coe, ZeroMemClass.coe_eq_zero]
      apply DirectSum.of_eq_of_ne
      exact id (Ne.symm h)
    have h_zero' : ‚àÄ i ‚â† 2, (GradedRing.proj (fun (n : ‚Ñï) ‚Ü¶ (LinearMap.range (Œπ : L ‚Üí‚Çó[R] TensorAlgebra R L) ^ n)) i (Œπ y * Œπ x)) = 0 := by
      intro i h
      rw [GradedRing.proj_apply, h_decompose']
      simp only [DirectSum.decompose_coe, ZeroMemClass.coe_eq_zero]
      apply DirectSum.of_eq_of_ne
      exact id (Ne.symm h)
    by_cases h0 : i = 2
    ¬∑ constructor
      rw [h0]
      simp only [GradedRing.proj_apply]
      rw [‚Üêh_decompose, ‚Üêh_decompose']
      exact this
    ¬∑ rw [‚Üêne_eq] at h0
      constructor
      have h_zeroh : (GradedRing.proj (fun (n : ‚Ñï) ‚Ü¶ (LinearMap.range (Œπ : L ‚Üí‚Çó[R] TensorAlgebra R L) ^ n)) i (Œπ x * Œπ y)) = 0 := by exact h_zero i h0
      have h_zeroh' : (GradedRing.proj (fun (n : ‚Ñï) ‚Ü¶ (LinearMap.range (Œπ : L ‚Üí‚Çó[R] TensorAlgebra R L) ^ n)) i (Œπ y * Œπ x)) = 0 := by exact h_zero' i h0
      rw [h_zeroh, h_zeroh']
      have zero : 0 = (Œπ (0 : L) * Œπ (0 : L)) := by simp only [map_zero, mul_zero]
      rw [zero]
      exact SymRel.mul_comm 0 0
‚ü©

abbrev SymmetricAlgebra := RingQuot (SymRel R L)


variable {R} {L} in
structure IsSymAlg {RL : Type*}
              [CommRing RL] [a : Algebra R RL]
              (iota : L ‚Üí‚Çó[R] RL) : Prop where
  ex_map {A : Type*} [CommRing A] [Algebra R A] (œÜ : L ‚Üí‚Çó[R] A)
    : ‚àÉ! œÜ' : RL ‚Üí‚Çê[R] A, œÜ = œÜ'.toLinearMap ‚àò‚Çó iota
  ex_map_self (œÜ : L ‚Üí‚Çó[R] RL) : ‚àÉ! œÜ' : RL ‚Üí‚Çê[R] RL, œÜ = œÜ'.toLinearMap ‚àò‚Çó iota






local notation "ùîñ" => SymmetricAlgebra



namespace SymmetricAlgebra

-- This is lemma 1
instance : CommRing (ùîñ R L) where
  mul_comm a b := match a, b with
    | ‚ü®a‚ü©, ‚ü®b‚ü© => by
      apply Quot.ind _ a; apply Quot.ind _ b; intro a b;
      rw [mul_quot, mul_quot]
      suffices h : ‚àÄ (x : TensorAlgebra R L), (‚ü®Quot.mk (RingQuot.Rel (SymRel R L)) (x * a)‚ü© : (RingQuot (SymRel R L))) = ‚ü®Quot.mk (RingQuot.Rel (SymRel R L)) (a * x)‚ü© by
        exact (h b)
      let P : TensorAlgebra R L ‚Üí TensorAlgebra R L ‚Üí Prop := fun x y ‚Ü¶ (‚ü®Quot.mk (RingQuot.Rel (SymRel R L)) (x * y)‚ü© : (RingQuot (SymRel R L))) = ‚ü®Quot.mk (RingQuot.Rel (SymRel R L)) (y * x)‚ü©
      have P_smul (r : R) (x : TensorAlgebra R L) : P x (algebraMap R (TensorAlgebra R L) r) := by
        unfold P; rw [Algebra.commutes]
      have P_mul (x y z : TensorAlgebra R L) (h1 : P z x) (h2 : P z y) : P z (x * y) := by
        unfold P at h1 h2 ‚ä¢
        rw [‚Üê mul_quot, ‚Üê mul_quot, ‚Üê mul_quot, ‚Üê mul_quot, ‚Üê mul_assoc, mul_quot, h1, ‚Üê mul_quot, mul_assoc, mul_quot, h2, ‚Üê mul_quot, mul_assoc]
      have P_add (x y z : TensorAlgebra R L) (h1 : P z x) (h2 : P z y) : P z (x + y) := by
        unfold P at h1 h2 ‚ä¢
        rw [mul_add, add_mul, ‚Üê add_quot, ‚Üê add_quot, h1, h2]
      have P_symm {x y : TensorAlgebra R L} (h : P x y) : P y x := h.symm
      have P_base (x y : L) : P (Œπ x) (Œπ y) := by
        unfold P
        rw [Quot.sound (Rel.of (SymRel.mul_comm x y))]
      apply TensorAlgebra.induction (C := fun y ‚Ü¶ ‚àÄ (x : TensorAlgebra R L), P x y) _ _ _ _ a
      ¬∑ intro r; exact P_smul r
      ¬∑ intro x; apply TensorAlgebra.induction
        ¬∑ intro r; exact P_symm (P_smul r (Œπ x))
        ¬∑ intro y; exact P_base y x
        ¬∑ intro a1 a2 h1 h2; exact P_symm (P_mul a1 a2 (Œπ x) (P_symm h1) (P_symm h2))
        ¬∑ intro a1 a2 h1 h2; exact P_symm (P_add a1 a2 (Œπ x) (P_symm h1) (P_symm h2))
      ¬∑ intro a1 a2 h1 h2 x; exact P_mul a1 a2 x (h1 x) (h2 x)
      ¬∑ intro a1 a2 h1 h2 x; exact P_add a1 a2 x (h1 x) (h2 x)

--#check IsSymAlg (ùîñ R L)

abbrev mkAlgHom : TensorAlgebra R L ‚Üí‚Çê[R] ùîñ R L := RingQuot.mkAlgHom R (SymRel R L)

def iota : L ‚Üí‚Çó[R] ùîñ R L := (mkAlgHom R L).toLinearMap.comp (TensorAlgebra.Œπ R (M := L))


/-
This says that the symmetric algebra over R of the zero module
(here defined as any module which has at most one element) must be isomorphic
as an R algebra to R.
-/
def symAlgOfZeroModule {RZ M : Type*} [CommRing RZ] [Algebra R RZ]
  [AddCommMonoid M] [Module R M] (hm : Subsingleton M) : IsSymAlg (R := R) (L := M) (RL := R) 0 := {
    ex_map := by
      intro a b c œÜ
      have hœÜ : œÜ = 0 := by exact Subsingleton.eq_zero œÜ
      -- R is initial in the category of R-algebras, so this morphism is unique
      let œÜ' : R ‚Üí‚Çê[R] a := Algebra.ofId R a
      use œÜ'
      constructor
      ¬∑ -- Prove relation holds
        rw [hœÜ]
        ext x
        simp only [LinearMap.zero_apply, LinearMap.comp_zero]
      ¬∑ -- Prove uniqueness (should hold by definition)
         intro œà hœà
         exact Algebra.ext_id_iff.mpr trivial
    ex_map_self := by
      intro œÜ
      have hœÜ : œÜ = 0 := by exact Subsingleton.eq_zero œÜ
      -- R is initial in the category of R-algebras, so this morphism is unique
      let œÜ' : R ‚Üí‚Çê[R] R := Algebra.ofId R R
      use œÜ'
      constructor
      ¬∑ -- Prove relation holds
        rw [hœÜ]
        ext x
        simp only [LinearMap.zero_apply, LinearMap.comp_zero]
      ¬∑ -- Prove uniqueness (should hold by definition)
         intro œà hœà
         exact Algebra.ext_id_iff.mpr trivial
  }

/-
Use TensorAlgebra.lift and RingQuot.lift for existence and TensorAlgebra.lift_unique
for uniqueness
-/
def lem2 : IsSymAlg (iota R L) where
  ex_map := by
    intro alg com halg œÜ
    let tensorphi : TensorAlgebra R L ‚Üí‚Çê[R] alg := TensorAlgebra.lift R œÜ

    -- Define a morphism out of the symmetric algebra using RingQuot.lift
    let res : ‚àÄ ‚¶Éx y : TensorAlgebra R L‚¶Ñ, SymRel R L x y ‚Üí tensorphi x = tensorphi y := by
        intro x y h
        induction h
        case mul_comm x y =>
          simp only [map_mul]
          rw [@NonUnitalCommSemiring.mul_comm]

    use (RingQuot.liftAlgHom (S := R) (s := SymRel R L) (B := alg)) ‚ü®TensorAlgebra.lift R œÜ, res‚ü©
    constructor
    ¬∑ unfold iota
      have teneq := TensorAlgebra.lift.eq_1 (M := L) (A := alg) R
      have quoteq := RingQuot.eq_liftAlgHom_comp_mkAlgHom R (TensorAlgebra.lift R œÜ)
      ext a
      simp
    ¬∑ intro a b
      apply RingQuot.liftAlgHom_unique
      exact
        (TensorAlgebra.lift_unique œÜ (a.comp (RingQuot.mkAlgHom R (SymRel R L)))).mp
          (id (Eq.symm b))
  ex_map_self := by
    intro œÜ
    let tensorphi : TensorAlgebra R L ‚Üí‚Çê[R] ùîñ R L:= TensorAlgebra.lift R œÜ

    -- Define a morphism out of the symmetric algebra using RingQuot.lift
    let res : ‚àÄ ‚¶Éx y : TensorAlgebra R L‚¶Ñ, SymRel R L x y ‚Üí tensorphi x = tensorphi y := by
        intro x y h
        induction h
        case mul_comm x y =>
          simp only [map_mul]
          rw [@NonUnitalCommSemiring.mul_comm]

    use (RingQuot.liftAlgHom (S := R) (s := SymRel R L) (B := ùîñ R L)) ‚ü®TensorAlgebra.lift R œÜ, res‚ü©
    constructor
    ¬∑ unfold iota
      have teneq := TensorAlgebra.lift.eq_1 (M := L) (A := ùîñ R L) R
      have quoteq := RingQuot.eq_liftAlgHom_comp_mkAlgHom R (TensorAlgebra.lift R œÜ)
      ext a
      simp
    ¬∑ intro a b
      apply RingQuot.liftAlgHom_unique
      exact
        (TensorAlgebra.lift_unique œÜ (a.comp (RingQuot.mkAlgHom R (SymRel R L)))).mp
          (id (Eq.symm b))

 def IsSymAlg.lift {M M' : Type*} [AddCommMonoid M] [Module R M]
         {RM : Type*}
         [CommRing RM] [Algebra R RM] [CommRing M'] [Algebra R M']
         {iM : M ‚Üí‚Çó[R] RM} (salg : IsSymAlg iM) (phi : M ‚Üí‚Çó[R] M') : RM ‚Üí‚Çê[R] M' :=
  (salg.ex_map phi).choose

/-
Any two morphisms iM : M ‚Üí‚Çó[R] RM and iM' : M ‚Üí‚Çó[R] RM' both satisfying isSymAlg must
have that RM and RM' are isomorphic
-/

theorem IsSymAlg.lift_spec {M M' : Type*} [AddCommMonoid M] [Module R M]
         {RM : Type*}
         [CommRing RM] [Algebra R RM] [CommRing M'] [Algebra R M']
         {iM : M ‚Üí‚Çó[R] RM} (salg : IsSymAlg iM) (phi : M ‚Üí‚Çó[R] M')
         : phi = (IsSymAlg.lift _ salg phi).toLinearMap ‚àò‚Çó iM := by
  exact (salg.ex_map phi).choose_spec.1

theorem IsSymAlg.comp_spec {M : Type*} [AddCommMonoid M] [Module R M]
         {RM RM' : Type*}
         [CommRing RM] [Algebra R RM] [CommRing RM'] [Algebra R RM']
         {iM : M ‚Üí‚Çó[R] RM} {iM' : M ‚Üí‚Çó[R] RM'} (salg : IsSymAlg iM) (salg' : IsSymAlg iM'):
  iM = ((AlgHom.comp (IsSymAlg.lift _ salg' iM) (IsSymAlg.lift _ salg iM')).toLinearMap) ‚àò‚Çó iM := by
  rw [AlgHom.comp_toLinearMap]
  rw [LinearMap.comp_assoc]
  rw [‚Üê IsSymAlg.lift_spec _ salg iM']
  exact IsSymAlg.lift_spec _ salg' iM

def IsSymAlgIsoInvariant {M : Type*} [AddCommMonoid M] [Module R M]
         {RM RM' : Type*}
         [CommRing RM] [Algebra R RM] [CommRing RM'] [Algebra R RM']
         {iM : M ‚Üí‚Çó[R] RM} {iM' : M ‚Üí‚Çó[R] RM'} (salg : IsSymAlg iM) (salg' : IsSymAlg iM')
         : RM ‚âÉ‚Çê[R] RM' where
    toFun : RM ‚Üí‚Çê[R] RM' := IsSymAlg.lift R salg iM'
    invFun : RM' ‚Üí‚Çê[R] RM := IsSymAlg.lift R salg' iM
    -- Prove these properties using the universal property
    left_inv := by
      rw [@Function.leftInverse_iff_comp]
      let œÜ := IsSymAlg.lift R salg iM'
      let œà := IsSymAlg.lift R salg' iM

      have h1 : iM' = œÜ ‚àò‚Çó iM := (salg.ex_map iM').choose_spec.1
      have h2 : iM = œà ‚àò‚Çó iM' := (salg'.ex_map iM).choose_spec.1
      have h3 : ((AlgHom.comp œà œÜ).toLinearMap) ‚àò iM = (AlgHom.id R RM).toLinearMap ‚àò‚Çó iM := by
        nth_rw 2 [h2]
        rw [h1]
        simp only [AlgHom.comp_toLinearMap, LinearMap.coe_comp, AlgHom.toLinearMap_id,
          LinearMap.id_comp, LieHom.coe_toLinearMap, AlgHom.coe_toLieHom]
        exact rfl

      have comp_spec := IsSymAlg.comp_spec _ salg salg'
      -- Both œÜ' ‚àò œÜ and id satisfy the property from ex_map_self
      have prop1 : iM = (AlgHom.comp œà œÜ).toLinearMap ‚àò‚Çó iM := by exact comp_spec
      have prop2 : iM = (AlgHom.id R RM).toLinearMap ‚àò‚Çó iM := by exact rfl

      -- Use uniqueness to conclude they are equal
      have h_unique := (salg.ex_map_self iM).unique prop1 prop2
      --exact h_unique ‚ñ∏ (AlgHom.id_apply R RM x)
      have eq: (AlgHom.comp œà œÜ) = (AlgHom.id R RM) := by exact h_unique
      unfold œÜ œà at eq
      have : (AlgHom.id R RM) = (id : RM ‚Üí RM) := by rfl
      have this1 : ‚áë(IsSymAlg.lift R salg' iM) ‚àò ‚áë(IsSymAlg.lift R salg iM') = (AlgHom.comp œà œÜ) := by rfl
      rw [‚Üêthis, this1, eq]

    right_inv := by
      rw [@Function.rightInverse_iff_comp]
      let œÜ := IsSymAlg.lift R salg iM'
      let œà := IsSymAlg.lift R salg' iM
      have h1 : iM' = œÜ ‚àò‚Çó iM := (salg.ex_map iM').choose_spec.1
      have h2 : iM = œà ‚àò‚Çó iM' := (salg'.ex_map iM).choose_spec.1
      have h3 : ((AlgHom.comp œÜ œà).toLinearMap) ‚àò iM' = (AlgHom.id R RM').toLinearMap ‚àò‚Çó iM' := by
        nth_rw 2 [h1]
        rw [h2]
        simp only [AlgHom.comp_toLinearMap, LinearMap.coe_comp, AlgHom.toLinearMap_id,
          LinearMap.id_comp, LieHom.coe_toLinearMap, AlgHom.coe_toLieHom]
        rfl

      have comp_spec := IsSymAlg.comp_spec _ salg' salg
      -- Both œÜ' ‚àò œÜ and id satisfy the property from ex_map_self
      have prop1 : iM' = (AlgHom.comp œÜ œà).toLinearMap ‚àò‚Çó iM' := by exact comp_spec
      have prop2 : iM' = (AlgHom.id R RM').toLinearMap ‚àò‚Çó iM' := by exact rfl

      -- Use uniqueness to conclude they are equal
      have h_unique := (salg'.ex_map_self iM').unique prop1 prop2
      --exact h_unique ‚ñ∏ (AlgHom.id_apply R RM x)
      have eq: (AlgHom.comp œÜ œà) = (AlgHom.id R RM') := by exact h_unique
      unfold œÜ œà at eq
      have : (AlgHom.id R RM') = (id : RM' ‚Üí RM') := by rfl
      have this1 : ‚áë(IsSymAlg.lift R salg iM') ‚àò ‚áë(IsSymAlg.lift R salg' iM) = (AlgHom.comp œÜ œà) := by rfl
      rw [‚Üêthis, this1, eq]
    map_mul' := by simp only [map_mul, implies_true]
    map_add' := by simp only [map_add, implies_true]
    commutes' := by simp only [AlgHom.commutes, implies_true]






theorem IsSymAlg.liftCorrect {M M' : Type*} [AddCommMonoid M] [Module R M]
         {RM : Type*}
         [CommRing RM] [a : Algebra R RM] [CommRing M'] [Algebra R M']
         {iM : M ‚Üí‚Çó[R] RM} (salg : IsSymAlg iM) (phi : M ‚Üí‚Çó[R] M') :
         ((IsSymAlg.lift R salg phi) ‚àò‚Çó iM) = phi := ((salg.ex_map phi).choose_spec.1).symm



def freeRkOneToPoly {M : Type*} [AddCommGroup M] [Module R M]
  [Nontrivial R] (mf : Module.Free R M)
  (r1 : Module.finrank R M = 1) : M ‚Üí‚Çó[R] Polynomial R :=
    have : Module.Finite R M := Module.finite_of_finrank_eq_succ r1
    let B := Module.finBasis R M
    Basis.constr B R (fun _ ‚Ü¶ Polynomial.X)
/-


Use Polynomial.aeval to construct an alegbra morphism from Polynomial R to A sending
x to œÜ(e), where is a . We then wish to show that this morphism and the morphism constructed in=
the previous paragraph are inverses of one another

You may need to use Polynomial.algHom_ext in order to prove things about equivalences
between maps out of Polynomial R
-/


def lem3 {M : Type*} [AddCommGroup M] [Module R M] (mf : Module.Free R M)
             (r1 : Module.finrank R M = 1) [Nontrivial R]
             : IsSymAlg (freeRkOneToPoly R mf r1) := {
    ex_map := by
      intro A rA aA œÜ
      have : Module.Finite R M := Module.finite_of_finrank_eq_succ r1
      let B := Module.finBasis R M
      -- Take e to be the unique element of our basis B

      let idx : Fin (Module.finrank R M) := Fin.mk 0 (by rw [r1]; exact Nat.zero_lt_one)
      let e : M := B ‚ü®0, by aesop‚ü©
      -- Use Polynomial.aeval to define a morphism œÜ' : Polynomial R ‚Üí‚Çê[R] A which
      -- takes X and maps it to œÜ(e)
      let œÜ' : Polynomial R ‚Üí‚Çê[R] A := Polynomial.aeval (œÜ e)

      use œÜ'
      constructor
      ¬∑ simp only
        have (x : M) : ‚àÉ (y : R), x = y ‚Ä¢ e := by
          use (B.repr x) (Fin.mk 0 (by rw [r1]; exact Nat.zero_lt_one))
          rw [‚Üê B.sum_repr x, Finset.sum_eq_single (Fin.mk 0 (by rw [r1]; exact Nat.zero_lt_one))]
          ¬∑ simp only [map_smul, Basis.repr_self, Finsupp.smul_single, smul_eq_mul, mul_one,
            Finsupp.single_eq_same]
          ¬∑ intro i hi1 hi2
            have this :  i = idx := by
              have : Fintype.card (Fin (Module.finrank R M)) ‚â§ 1 := by
                simp only [Fintype.card_fin]
                exact Nat.le_of_eq r1
              apply Fintype.card_le_one_iff.mp this
            have this' : i ‚â† idx := by exact hi2
            contradiction
          ¬∑ intro h
            have : idx ‚àà Finset.univ := by
              simp only [Finset.mem_univ]
            exact False.elim (h this)
        rw [@LinearMap.ext_iff]
        intro x
        specialize this x
        rcases this with ‚ü®y, hy‚ü©
        rw [hy]
        simp only [map_smul, LinearMap.coe_comp, LieHom.coe_toLinearMap, AlgHom.coe_toLieHom,
          Function.comp_apply]
        have: œÜ e = œÜ' ((freeRkOneToPoly R mf r1) e) := by
          have : Polynomial.X = (freeRkOneToPoly R mf r1) e := by
            unfold freeRkOneToPoly
            simp only [Polynomial.aeval_X]
            exact Eq.symm (Basis.constr_basis (Module.finBasis R M) R (fun x ‚Ü¶ Polynomial.X) idx)
          rw [‚Üêthis]
          exact Eq.symm (Polynomial.aeval_X (œÜ e))
        rw [this]
        simp only [AlgHom.toLinearMap_apply]
      ¬∑ intro g
        simp
        intro hg
        -- Here, use Polynomial.algHom_ext to prove uniqueness
        apply Polynomial.algHom_ext
        have : œÜ' Polynomial.X = œÜ e := by exact Polynomial.aeval_X (œÜ e)
        have this': g Polynomial.X = œÜ e := by
          rw [hg]
          simp only [LinearMap.coe_comp, LieHom.coe_toLinearMap, AlgHom.coe_toLieHom,
            Function.comp_apply]
          apply AlgHom.congr_arg
          have : (freeRkOneToPoly R mf r1) e = Basis.constr B R (fun _ ‚Ü¶ Polynomial.X) e := by
            simp [freeRkOneToPoly, Basis.constr]
          rw [this]
          exact Eq.symm (Basis.constr_basis B R (fun x ‚Ü¶ Polynomial.X) idx)
        rw [this, this']
    ex_map_self := by
      intro œÜ
      have : Module.Finite R M := Module.finite_of_finrank_eq_succ r1
      let B := Module.finBasis R M
      -- Take e to be the unique element of our basis B

      let idx : Fin (Module.finrank R M) := Fin.mk 0 (by rw [r1]; exact Nat.zero_lt_one)
      let e : M := B ‚ü®0, by aesop‚ü©
      -- Use Polynomial.aeval to define a morphism œÜ' : Polynomial R ‚Üí‚Çê[R] A which
      -- takes X and maps it to œÜ(e)
      let œÜ' : Polynomial R ‚Üí‚Çê[R] Polynomial R := Polynomial.aeval (œÜ e)

      use œÜ'
      constructor
      ¬∑ simp only
        have (x : M) : ‚àÉ (y : R), x = y ‚Ä¢ e := by
          use (B.repr x) (Fin.mk 0 (by rw [r1]; exact Nat.zero_lt_one))
          rw [‚Üê B.sum_repr x, Finset.sum_eq_single (Fin.mk 0 (by rw [r1]; exact Nat.zero_lt_one))]
          ¬∑ simp only [map_smul, Basis.repr_self, Finsupp.smul_single, smul_eq_mul, mul_one,
            Finsupp.single_eq_same]
          ¬∑ intro i hi1 hi2
            have this :  i = idx := by
              have : Fintype.card (Fin (Module.finrank R M)) ‚â§ 1 := by
                simp only [Fintype.card_fin]
                exact Nat.le_of_eq r1
              apply Fintype.card_le_one_iff.mp this
            have this' : i ‚â† idx := by exact hi2
            contradiction
          ¬∑ intro h
            have : idx ‚àà Finset.univ := by
              simp only [Finset.mem_univ]
            exact False.elim (h this)
        rw [@LinearMap.ext_iff]
        intro x
        specialize this x
        rcases this with ‚ü®y, hy‚ü©
        rw [hy]
        simp only [map_smul, LinearMap.coe_comp, LieHom.coe_toLinearMap, AlgHom.coe_toLieHom,
          Function.comp_apply]
        have: œÜ e = œÜ' ((freeRkOneToPoly R mf r1) e) := by
          have : Polynomial.X = (freeRkOneToPoly R mf r1) e := by
            unfold freeRkOneToPoly
            simp only [Polynomial.aeval_X]
            exact Eq.symm (Basis.constr_basis (Module.finBasis R M) R (fun x ‚Ü¶ Polynomial.X) idx)
          rw [‚Üêthis]
          exact Eq.symm (Polynomial.aeval_X (œÜ e))
        rw [this]
        simp only [AlgHom.toLinearMap_apply]
      ¬∑ intro g
        simp
        intro hg
        -- Here, use Polynomial.algHom_ext to prove uniqueness
        apply Polynomial.algHom_ext
        have : œÜ' Polynomial.X = œÜ e := by exact Polynomial.aeval_X (œÜ e)
        have this': g Polynomial.X = œÜ e := by
          rw [hg]
          simp only [LinearMap.coe_comp, LieHom.coe_toLinearMap, AlgHom.coe_toLieHom,
            Function.comp_apply]
          apply AlgHom.congr_arg
          have : (freeRkOneToPoly R mf r1) e = Basis.constr B R (fun _ ‚Ü¶ Polynomial.X) e := by
            simp [freeRkOneToPoly, Basis.constr]
          rw [this]
          exact Eq.symm (Basis.constr_basis B R (fun x ‚Ü¶ Polynomial.X) idx)
        rw [this, this']
  }



/-
Functoriality: Take iM' ‚àò phi to get a map from M to R[M'], then use the universal
property to lift this to a map from R[M] to R[M']
-/
def lem5 {M M' : Type*} [AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']
         {RM RM' : Type*}
         [CommRing RM] [a : Algebra R RM] [CommRing RM'] [a : Algebra R RM']
         {iM : M ‚Üí‚Çó[R] RM} {iM' : M' ‚Üí‚Çó[R] RM'} (salg : IsSymAlg iM)
         (salg' : IsSymAlg iM') (phi : M ‚Üí‚Çó[R] M') : RM ‚Üí‚Çê[R] RM' :=
    IsSymAlg.lift R salg (iM'.comp phi)

-- Define the natural map from RM‚ÇÅ ‚äó[R] RM‚ÇÇ to RM defined
open TensorProduct
def lem6Map {M‚ÇÅ M‚ÇÇ : Type*}
            [AddCommMonoid M‚ÇÅ] [Module R M‚ÇÅ]
            [AddCommMonoid M‚ÇÇ] [Module R M‚ÇÇ]
         {RM RM‚ÇÅ RM‚ÇÇ : Type*}
         [CommRing RM] [Algebra R RM] [CommRing RM‚ÇÅ] [Algebra R RM‚ÇÅ]
         [CommRing RM‚ÇÇ] [Algebra R RM‚ÇÇ]
         {iM : M‚ÇÅ √ó M‚ÇÇ ‚Üí‚Çó[R] RM} {iM‚ÇÅ : M‚ÇÅ ‚Üí‚Çó[R] RM‚ÇÅ} {iM‚ÇÇ : M‚ÇÇ ‚Üí‚Çó[R] RM‚ÇÇ}
         (salg : IsSymAlg iM) (salg‚ÇÅ : IsSymAlg iM‚ÇÅ) (salg‚ÇÇ : IsSymAlg iM‚ÇÇ)
         : RM‚ÇÅ ‚äó[R] RM‚ÇÇ ‚Üí‚Çê[R] RM := by
  let œÜ‚ÇÅ : M‚ÇÅ ‚Üí‚Çó[R] RM := LinearMap.comp iM (LinearMap.prod LinearMap.id 0)
  let œÜ‚ÇÇ : M‚ÇÇ ‚Üí‚Çó[R] RM := LinearMap.comp iM (LinearMap.prod 0 LinearMap.id)

  let œÜ‚ÇÅ_alg : RM‚ÇÅ ‚Üí‚Çê[R] RM := (salg‚ÇÅ.ex_map œÜ‚ÇÅ).exists.choose
  let œÜ‚ÇÇ_alg : RM‚ÇÇ ‚Üí‚Çê[R] RM := (salg‚ÇÇ.ex_map œÜ‚ÇÇ).exists.choose

  let bilin_map : RM‚ÇÅ ‚Üí‚Çó[R] RM‚ÇÇ ‚Üí‚Çó[R] RM := by
    refine LinearMap.mk‚ÇÇ R (fun x y => œÜ‚ÇÅ_alg x * œÜ‚ÇÇ_alg y) ?_ ?_ ?_ ?_
    ¬∑ intros x y z
      simp only [map_add]
      exact RightDistribClass.right_distrib (œÜ‚ÇÅ_alg x) (œÜ‚ÇÅ_alg y) (œÜ‚ÇÇ_alg z)
    ¬∑ intros r x y
      simp [Algebra.smul_def, mul_assoc]
    ¬∑ intros x y z
      simp [add_mul]
      exact LeftDistribClass.left_distrib (œÜ‚ÇÅ_alg x) (œÜ‚ÇÇ_alg y) (œÜ‚ÇÇ_alg z)
    ¬∑ intros r x y
      simp [Algebra.smul_def, mul_assoc]
      exact Algebra.left_comm (œÜ‚ÇÅ_alg x) r (œÜ‚ÇÇ_alg y)
  let lin_map : RM‚ÇÅ ‚äó[R] RM‚ÇÇ ‚Üí‚Çó[R] RM := TensorProduct.lift bilin_map
  exact Algebra.TensorProduct.productMap œÜ‚ÇÅ_alg œÜ‚ÇÇ_alg




variable (I : Type*) (basis_I : Basis I R L)

def basisToPoly : L ‚Üí‚Çó[R] MvPolynomial I R :=
    Basis.constr basis_I R (fun i ‚Ü¶ MvPolynomial.X i)

/-
This should be a more conceptual version of the proof below
-/
def cor1 : IsSymAlg (basisToPoly R L I basis_I) where
  ex_map := by
    intro alg b c œÜ
    simp[basisToPoly]

    use MvPolynomial.aeval (R := R) (fun i => œÜ (basis_I i))
    constructor
    ¬∑ apply Basis.ext basis_I
      intro i
      simp

    ¬∑ simp
      intro f hf
      apply MvPolynomial.algHom_ext
      intro i
      simp only [aeval_X]
      -- Should be very simple to prove this
      rw [hf]
      simp only [LinearMap.coe_comp, LieHom.coe_toLinearMap, AlgHom.coe_toLieHom,
        Function.comp_apply, Basis.constr_basis]
      simp only [AlgHom.toLinearMap_apply]
  ex_map_self := by
    intro œÜ
    simp[basisToPoly]

    use MvPolynomial.aeval (R := R) (fun i => œÜ (basis_I i))
    constructor
    ¬∑ apply Basis.ext basis_I
      intro i
      simp

    ¬∑ simp
      intro f hf
      apply MvPolynomial.algHom_ext
      intro i
      simp only [bind‚ÇÅ_X_right]
      -- Should be very simple to prove this
      rw [hf]
      simp only [LinearMap.coe_comp, LieHom.coe_toLinearMap, AlgHom.coe_toLieHom,
        Function.comp_apply, Basis.constr_basis]
      simp only [AlgHom.toLinearMap_apply]



def symmetric_algebra_iso_mv_polynomial : MvPolynomial I R ‚âÉ‚Çê[R] ùîñ R L :=
  AlgEquiv.ofAlgHom
    ‚ü®eval‚ÇÇHom (algebraMap R (ùîñ R L)) (fun i ‚Ü¶ mkRingHom _ (Œπ (basis_I i))), fun _ ‚Ü¶ eval‚ÇÇ_C _ _ _‚ü©
    (liftAlgHom R ‚ü®TensorAlgebra.lift R ((Finsupp.linearCombination R (fun (i : I) ‚Ü¶ ((X i) : MvPolynomial I R))).comp basis_I.repr.1), fun {u v} h ‚Ü¶ match h with | SymRel.mul_comm x y => by simp [mul_comm]‚ü©)
    (by
      apply ringQuot_ext'; apply TensorAlgebra.hom_ext; apply Basis.ext basis_I; intro i
      simp [SymmetricAlgebra]; rw [RingQuot.mkAlgHom, AlgHom.coe_mk])
    (by
      apply algHom_ext; intro i
      simp only [AlgHom.coe_comp, AlgHom.coe_mk, coe_eval‚ÇÇHom, Function.comp_apply, eval‚ÇÇ_X,
        AlgHom.coe_id, id_eq]
      have h1 : (mkRingHom (SymRel R L)) (Œπ (basis_I i)) = (RingQuot.mkAlgHom R (SymRel R L)) (Œπ (basis_I i)) := by rw [RingQuot.mkAlgHom, AlgHom.coe_mk]
      have h2 : ((TensorAlgebra.lift R) ((Finsupp.linearCombination R fun i => (X i : MvPolynomial I R)) ‚àò‚Çó basis_I.repr.1)) (Œπ (basis_I i)) = X i := by simp
      rw [‚Üê h2, h1]
      apply liftAlgHom_mkAlgHom_apply)

abbrev gradingSymmetricAlgebra : ‚Ñï ‚Üí Submodule R (ùîñ R L) :=
  (Submodule.map (mkAlgHom R L)).comp
    (LinearMap.range (TensorAlgebra.Œπ R : L ‚Üí‚Çó[R] TensorAlgebra R L) ^ ¬∑)


#synth GradedAlgebra (gradingSymmetricAlgebra R L)

lemma proj_comm (x : TensorAlgebra R L) (m : ‚Ñï) : mkAlgHom R L ((GradedAlgebra.proj ((LinearMap.range (TensorAlgebra.Œπ R : L ‚Üí‚Çó[R] TensorAlgebra R L) ^ ¬∑)) m) x) = (GradedAlgebra.proj (gradingSymmetricAlgebra R L) m) (mkAlgHom R L x) := by
  unfold mkAlgHom
  unfold GradedAlgebra.proj
  simp only [AlgEquiv.toAlgHom_eq_coe, AlgEquiv.toAlgHom_toLinearMap, LinearMap.coe_comp,
    Submodule.coe_subtype, Function.comp_apply, DFinsupp.lapply_apply]
  induction x using TensorAlgebra.induction
  case algebraMap r =>
    simp only [AlgHom.commutes]
    sorry
  case mul a b ha hb =>
    simp only [map_mul]
    sorry
  case add a b ha hb =>
    simp only [map_add, DFinsupp.coe_add, Pi.add_apply, Submodule.coe_add]
    exact Mathlib.Tactic.LinearCombination.add_eq_eq ha hb
  case _ x =>
    sorry
